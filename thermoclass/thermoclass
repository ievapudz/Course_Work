#!/usr/bin/env python3.7

# A program that runs the model that classifies input protein
# to a thermostability class.

# Prerequisite:
# ESM extract.py program

import sys
import os
import torch
from optparse import OptionParser
from data_process import create_testing_data
from data_process import filter_sequences
from data_process import get_ESM_embeddings_as_tensor
from data_process import save_tensors_as_NPZ
from data_process import print_tensors_as_SV_to_file
from inference import load_tensor_from_NPZ
from inference import unlabelled_test_epoch
from torch.utils.data import DataLoader
from torch.utils.data import TensorDataset
from models import SLP_with_sigmoid

MODEL = './SLP_003.pt'

parser = OptionParser()
parser.add_option('--fasta', '-f', dest='fasta',
				   help='path to the input FASTA file')

parser.add_option('--generate', '-g', dest='generate', default=False,
				   action='store_true',
				   help='set to calculate embeddings for input sequences, '+\
						'by default embeddings are not generated')

parser.add_option('--per_tok', '-p', dest='per_tok',
				   action='store_true', default=False,				   
				   help='set to include per_tok representations in the generation '+\
						'of embeddings and make predictions for each amino acid '+\
						'by default mean embeddings are only created')

parser.add_option('--extract', dest='extract', 
				   default='../../programs/esm-0.4.0/extract.py',
				   help='path to the embeddings extraction script,\n'+\
						'default: ../../programs/esm-0.4.0/extract.py')

parser.add_option('--version', '-v', dest='version', action='store_true',
				   default=False,  
				   help='prints out the version of the program')

parser.add_option('--embeddings', '-e', dest='embeddings', default='./emb/',
				   help='path to the embeddings directory to save PT files, '+\
						'\ndefault: ./emb/')

parser.add_option('--output', '-o', dest='output', default='./output',
				   help='predictions output TSV file,\ndefault: ./output')

parser.add_option('--embeddings_npz', '-n', dest='emb_npz', default='./emb/esm_emb_1b.npz',
				   help='path to the embeddings NPZ files (if -g option is set, '+\
						'TSV file will get the same name),\ndefault: ./emb/esm_1b.npz')

parser.add_option('--npz_keywords', '-k', dest='npz_keywords', 
				   default='x_input y_input', 
				   help='NPZ file keywords with which the data was saved,\ndefault: '+\
						'\'x_input y_input\'')

(options, args) = parser.parse_args()

if(options.version):
	print(sys.argv[0]+': version 0.1.0-dev')
	exit

if(options.emb_npz == ''):
	options.emb_npz = options.fasta.split('.fasta')[0]

x_npz_keyword = options.npz_keywords.split(' ')[0]
y_npz_keyword = options.npz_keywords.split(' ')[1]

# Generation of input sequence embeddings
if(options.generate):
	print('Calculating embeddings')
	esm_extract_command = 'python3 '+options.extract+' esm1b_t33_650M_UR50S '+\
			  options.fasta+' '+options.embeddings+' --repr_layers 33 '+\
			  '--include mean'
	if(options.per_tok):
		esm_extract_command += ' per_tok'
	
	os.system(esm_extract_command)
	print('Embeddings calculated')

	# Creating testing data with mean or per_tok representations (depending on the input)
	emb_case = 0

	if(options.per_tok):
		emb_case = 1
			
	data = create_testing_data(options.fasta, options.embeddings, emb_case=emb_case,
                                labelled=False)

	filter_sequences(data, 'test', data['test']['embeddings'], False)

	# Save embeddings to NPZ and TSV files
	emb_key = 'mean_representations'
	
	if(options.per_tok):
		emb_key = 'representations'

	[Xs_input_tensor, Ys_input_tensor] = get_ESM_embeddings_as_tensor(data,
                                            ['test'], emb_key=emb_key)

	print("Saving tensors to an NPZ file")
	save_tensors_as_NPZ([Xs_input_tensor, Ys_input_tensor], 
					[x_npz_keyword, y_npz_keyword], 
					options.emb_npz)

	input_tensor = { x_npz_keyword: Xs_input_tensor, y_npz_keyword: Ys_input_tensor }

	print("Saving tensors to a TSV file")
	print_tensors_as_SV_to_file(data, input_tensor, 'test', [x_npz_keyword, y_npz_keyword],
							out_file_name=options.emb_npz.split('.npz')[0]+'.tsv', 
							sep="\t", labelled=False)

dataset = load_tensor_from_NPZ(options.emb_npz, [x_npz_keyword, y_npz_keyword])

input_dataset = TensorDataset(dataset[x_npz_keyword], dataset[y_npz_keyword])  
input_loader = DataLoader(input_dataset, shuffle=False)

# Load the trained SLP
model = SLP_with_sigmoid()
model.load_state_dict(torch.load(MODEL))
model.eval()

print('Inference process begins')

unlabelled_test_epoch(model, input_loader, 0.5, 
					  file_for_predictions=options.output.split('.tsv')[0]+'.tsv',
					  binary_predictions_only=False)

print('Inference process has finished')

os.system('echo "thermoclass finished:" `date`')

